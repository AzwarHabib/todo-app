{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { Observable } from 'rxjs';\nimport { GraphQLError } from 'graphql';\nimport { ConsoleLogger, fetchAuthSession, Hub } from '@aws-amplify/core';\nimport { signRequest } from '@aws-amplify/core/internals/aws-client-utils';\nimport { amplifyUuid, USER_AGENT_HEADER, getAmplifyUserAgent, isNonRetryableError, AmplifyUrlSearchParams, AmplifyUrl, base64Encoder, jitteredExponentialRetry, NonRetryableError, AMPLIFY_SYMBOL } from '@aws-amplify/core/internals/utils';\nimport { ConnectionState, CONTROL_MSG } from '../../types/PubSub.mjs';\nimport { SOCKET_STATUS, DEFAULT_KEEP_ALIVE_TIMEOUT, SUBSCRIPTION_STATUS, MESSAGE_TYPES, START_ACK_TIMEOUT, DEFAULT_KEEP_ALIVE_ALERT_TIMEOUT, MAX_DELAY_MS, CONNECTION_INIT_TIMEOUT, NON_RETRYABLE_CODES, AWS_APPSYNC_REALTIME_HEADERS, CONNECTION_STATE_CHANGE } from '../constants.mjs';\nimport { ConnectionStateMonitor, CONNECTION_CHANGE } from '../../utils/ConnectionStateMonitor.mjs';\nimport { ReconnectionMonitor, ReconnectEvent } from '../../utils/ReconnectionMonitor.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst logger = new ConsoleLogger('AWSAppSyncRealTimeProvider');\nconst dispatchApiEvent = payload => {\n  Hub.dispatch('api', payload, 'PubSub', AMPLIFY_SYMBOL);\n};\nconst standardDomainPattern = /^https:\\/\\/\\w{26}\\.appsync-api\\.\\w{2}(?:(?:-\\w{2,})+)-\\d\\.amazonaws.com(?:\\.cn)?\\/graphql$/i;\nconst customDomainPath = '/realtime';\nclass AWSAppSyncRealTimeProvider {\n  constructor() {\n    this.socketStatus = SOCKET_STATUS.CLOSED;\n    this.keepAliveTimeout = DEFAULT_KEEP_ALIVE_TIMEOUT;\n    this.subscriptionObserverMap = new Map();\n    this.promiseArray = [];\n    this.connectionStateMonitor = new ConnectionStateMonitor();\n    this.reconnectionMonitor = new ReconnectionMonitor();\n    // Monitor the connection state and pass changes along to Hub\n    this.connectionStateMonitorSubscription = this.connectionStateMonitor.connectionStateObservable.subscribe(connectionState => {\n      dispatchApiEvent({\n        event: CONNECTION_STATE_CHANGE,\n        data: {\n          provider: this,\n          connectionState\n        },\n        message: `Connection state is ${connectionState}`\n      });\n      this.connectionState = connectionState;\n      // Trigger START_RECONNECT when the connection is disrupted\n      if (connectionState === ConnectionState.ConnectionDisrupted) {\n        this.reconnectionMonitor.record(ReconnectEvent.START_RECONNECT);\n      }\n      // Trigger HALT_RECONNECT to halt reconnection attempts when the state is anything other than\n      //   ConnectionDisrupted or Connecting\n      if ([ConnectionState.Connected, ConnectionState.ConnectedPendingDisconnect, ConnectionState.ConnectedPendingKeepAlive, ConnectionState.ConnectedPendingNetwork, ConnectionState.ConnectionDisruptedPendingNetwork, ConnectionState.Disconnected].includes(connectionState)) {\n        this.reconnectionMonitor.record(ReconnectEvent.HALT_RECONNECT);\n      }\n    });\n  }\n  /**\n   * Mark the socket closed and release all active listeners\n   */\n  close() {\n    // Mark the socket closed both in status and the connection monitor\n    this.socketStatus = SOCKET_STATUS.CLOSED;\n    this.connectionStateMonitor.record(CONNECTION_CHANGE.CONNECTION_FAILED);\n    // Turn off the subscription monitor Hub publishing\n    this.connectionStateMonitorSubscription.unsubscribe();\n    // Complete all reconnect observers\n    this.reconnectionMonitor.close();\n  }\n  getNewWebSocket(url, protocol) {\n    return new WebSocket(url, protocol);\n  }\n  getProviderName() {\n    return 'AWSAppSyncRealTimeProvider';\n  }\n  // Check if url matches standard domain pattern\n  isCustomDomain(url) {\n    return url.match(standardDomainPattern) === null;\n  }\n  subscribe(options, customUserAgentDetails) {\n    const {\n      appSyncGraphqlEndpoint,\n      region,\n      query,\n      variables,\n      authenticationType,\n      additionalHeaders,\n      apiKey,\n      authToken,\n      libraryConfigHeaders\n    } = options || {};\n    return new Observable(observer => {\n      if (!options || !appSyncGraphqlEndpoint) {\n        observer.error({\n          errors: [{\n            ...new GraphQLError(`Subscribe only available for AWS AppSync endpoint`)\n          }]\n        });\n        observer.complete();\n      } else {\n        let subscriptionStartActive = false;\n        const subscriptionId = amplifyUuid();\n        const startSubscription = () => {\n          if (!subscriptionStartActive) {\n            subscriptionStartActive = true;\n            const startSubscriptionPromise = this._startSubscriptionWithAWSAppSyncRealTime({\n              options: {\n                query,\n                variables,\n                region,\n                authenticationType,\n                appSyncGraphqlEndpoint,\n                additionalHeaders,\n                apiKey,\n                authToken,\n                libraryConfigHeaders\n              },\n              observer,\n              subscriptionId,\n              customUserAgentDetails\n            }).catch(err => {\n              logger.debug(`${CONTROL_MSG.REALTIME_SUBSCRIPTION_INIT_ERROR}: ${err}`);\n              this.connectionStateMonitor.record(CONNECTION_CHANGE.CLOSED);\n            });\n            startSubscriptionPromise.finally(() => {\n              subscriptionStartActive = false;\n            });\n          }\n        };\n        // Add an observable to the reconnection list to manage reconnection for this subscription\n        const reconnectSubscription = new Observable(reconnectSubscriptionObserver => {\n          this.reconnectionMonitor.addObserver(reconnectSubscriptionObserver);\n        }).subscribe(() => {\n          startSubscription();\n        });\n        startSubscription();\n        return async () => {\n          // Cleanup reconnection subscription\n          reconnectSubscription?.unsubscribe();\n          // Cleanup after unsubscribing or observer.complete was called after _startSubscriptionWithAWSAppSyncRealTime\n          try {\n            // Waiting that subscription has been connected before trying to unsubscribe\n            await this._waitForSubscriptionToBeConnected(subscriptionId);\n            const {\n              subscriptionState\n            } = this.subscriptionObserverMap.get(subscriptionId) || {};\n            if (!subscriptionState) {\n              // subscription already unsubscribed\n              return;\n            }\n            if (subscriptionState === SUBSCRIPTION_STATUS.CONNECTED) {\n              this._sendUnsubscriptionMessage(subscriptionId);\n            } else {\n              throw new Error('Subscription never connected');\n            }\n          } catch (err) {\n            logger.debug(`Error while unsubscribing ${err}`);\n          } finally {\n            this._removeSubscriptionObserver(subscriptionId);\n          }\n        };\n      }\n    });\n  }\n  async _startSubscriptionWithAWSAppSyncRealTime({\n    options,\n    observer,\n    subscriptionId,\n    customUserAgentDetails\n  }) {\n    const {\n      appSyncGraphqlEndpoint,\n      authenticationType,\n      query,\n      variables,\n      apiKey,\n      region,\n      libraryConfigHeaders = () => ({}),\n      additionalHeaders = {},\n      authToken\n    } = options;\n    let additionalCustomHeaders = {};\n    if (typeof additionalHeaders === 'function') {\n      const requestOptions = {\n        url: appSyncGraphqlEndpoint || '',\n        queryString: query || ''\n      };\n      additionalCustomHeaders = await additionalHeaders(requestOptions);\n    } else {\n      additionalCustomHeaders = additionalHeaders;\n    }\n    // if an authorization header is set, have the explicit authToken take precedence\n    if (authToken) {\n      additionalCustomHeaders = {\n        ...additionalCustomHeaders,\n        Authorization: authToken\n      };\n    }\n    const subscriptionState = SUBSCRIPTION_STATUS.PENDING;\n    const data = {\n      query,\n      variables\n    };\n    // Having a subscription id map will make it simple to forward messages received\n    this.subscriptionObserverMap.set(subscriptionId, {\n      observer,\n      query: query ?? '',\n      variables: variables ?? {},\n      subscriptionState,\n      startAckTimeoutId: undefined\n    });\n    // Preparing payload for subscription message\n    const dataString = JSON.stringify(data);\n    const headerObj = {\n      ...(await this._awsRealTimeHeaderBasedAuth({\n        apiKey,\n        appSyncGraphqlEndpoint,\n        authenticationType,\n        payload: dataString,\n        canonicalUri: '',\n        region,\n        additionalCustomHeaders\n      })),\n      ...(await libraryConfigHeaders()),\n      ...additionalCustomHeaders,\n      [USER_AGENT_HEADER]: getAmplifyUserAgent(customUserAgentDetails)\n    };\n    const subscriptionMessage = {\n      id: subscriptionId,\n      payload: {\n        data: dataString,\n        extensions: {\n          authorization: {\n            ...headerObj\n          }\n        }\n      },\n      type: MESSAGE_TYPES.GQL_START\n    };\n    const stringToAWSRealTime = JSON.stringify(subscriptionMessage);\n    try {\n      this.connectionStateMonitor.record(CONNECTION_CHANGE.OPENING_CONNECTION);\n      await this._initializeWebSocketConnection({\n        apiKey,\n        appSyncGraphqlEndpoint,\n        authenticationType,\n        region,\n        additionalCustomHeaders\n      });\n    } catch (err) {\n      this._logStartSubscriptionError(subscriptionId, observer, err);\n      return;\n    }\n    // Potential race condition can occur when unsubscribe is called during _initializeWebSocketConnection.\n    // E.g.unsubscribe gets invoked prior to finishing WebSocket handshake or START_ACK.\n    // Both subscriptionFailedCallback and subscriptionReadyCallback are used to synchronized this.\n    const {\n      subscriptionFailedCallback,\n      subscriptionReadyCallback\n    } = this.subscriptionObserverMap.get(subscriptionId) ?? {};\n    // This must be done before sending the message in order to be listening immediately\n    this.subscriptionObserverMap.set(subscriptionId, {\n      observer,\n      subscriptionState,\n      query: query ?? '',\n      variables: variables ?? {},\n      subscriptionReadyCallback,\n      subscriptionFailedCallback,\n      startAckTimeoutId: setTimeout(() => {\n        this._timeoutStartSubscriptionAck(subscriptionId);\n      }, START_ACK_TIMEOUT)\n    });\n    if (this.awsRealTimeSocket) {\n      this.awsRealTimeSocket.send(stringToAWSRealTime);\n    }\n  }\n  // Log logic for start subscription failures\n  _logStartSubscriptionError(subscriptionId, observer, err) {\n    logger.debug({\n      err\n    });\n    const message = String(err.message ?? '');\n    // Resolving to give the state observer time to propogate the update\n    this.connectionStateMonitor.record(CONNECTION_CHANGE.CLOSED);\n    // Capture the error only when the network didn't cause disruption\n    if (this.connectionState !== ConnectionState.ConnectionDisruptedPendingNetwork) {\n      // When the error is non-retriable, error out the observable\n      if (isNonRetryableError(err)) {\n        observer.error({\n          errors: [{\n            ...new GraphQLError(`${CONTROL_MSG.CONNECTION_FAILED}: ${message}`)\n          }]\n        });\n      } else {\n        logger.debug(`${CONTROL_MSG.CONNECTION_FAILED}: ${message}`);\n      }\n      const {\n        subscriptionFailedCallback\n      } = this.subscriptionObserverMap.get(subscriptionId) || {};\n      // Notify concurrent unsubscription\n      if (typeof subscriptionFailedCallback === 'function') {\n        subscriptionFailedCallback();\n      }\n    }\n  }\n  // Waiting that subscription has been connected before trying to unsubscribe\n  async _waitForSubscriptionToBeConnected(subscriptionId) {\n    const subscriptionObserver = this.subscriptionObserverMap.get(subscriptionId);\n    if (subscriptionObserver) {\n      const {\n        subscriptionState\n      } = subscriptionObserver;\n      // This in case unsubscribe is invoked before sending start subscription message\n      if (subscriptionState === SUBSCRIPTION_STATUS.PENDING) {\n        return new Promise((resolve, reject) => {\n          const {\n            observer,\n            subscriptionState: observedSubscriptionState,\n            variables,\n            query\n          } = subscriptionObserver;\n          this.subscriptionObserverMap.set(subscriptionId, {\n            observer,\n            subscriptionState: observedSubscriptionState,\n            variables,\n            query,\n            subscriptionReadyCallback: resolve,\n            subscriptionFailedCallback: reject\n          });\n        });\n      }\n    }\n  }\n  _sendUnsubscriptionMessage(subscriptionId) {\n    try {\n      if (this.awsRealTimeSocket && this.awsRealTimeSocket.readyState === WebSocket.OPEN && this.socketStatus === SOCKET_STATUS.READY) {\n        // Preparing unsubscribe message to stop receiving messages for that subscription\n        const unsubscribeMessage = {\n          id: subscriptionId,\n          type: MESSAGE_TYPES.GQL_STOP\n        };\n        const stringToAWSRealTime = JSON.stringify(unsubscribeMessage);\n        this.awsRealTimeSocket.send(stringToAWSRealTime);\n      }\n    } catch (err) {\n      // If GQL_STOP is not sent because of disconnection issue, then there is nothing the client can do\n      logger.debug({\n        err\n      });\n    }\n  }\n  _removeSubscriptionObserver(subscriptionId) {\n    this.subscriptionObserverMap.delete(subscriptionId);\n    // Verifying 1000ms after removing subscription in case there are new subscription unmount/mount\n    setTimeout(this._closeSocketIfRequired.bind(this), 1000);\n  }\n  _closeSocketIfRequired() {\n    if (this.subscriptionObserverMap.size > 0) {\n      // Active subscriptions on the WebSocket\n      return;\n    }\n    if (!this.awsRealTimeSocket) {\n      this.socketStatus = SOCKET_STATUS.CLOSED;\n      return;\n    }\n    this.connectionStateMonitor.record(CONNECTION_CHANGE.CLOSING_CONNECTION);\n    if (this.awsRealTimeSocket.bufferedAmount > 0) {\n      // Still data on the WebSocket\n      setTimeout(this._closeSocketIfRequired.bind(this), 1000);\n    } else {\n      logger.debug('closing WebSocket...');\n      if (this.keepAliveTimeoutId) {\n        clearTimeout(this.keepAliveTimeoutId);\n      }\n      if (this.keepAliveAlertTimeoutId) {\n        clearTimeout(this.keepAliveAlertTimeoutId);\n      }\n      const tempSocket = this.awsRealTimeSocket;\n      // Cleaning callbacks to avoid race condition, socket still exists\n      tempSocket.onclose = null;\n      tempSocket.onerror = null;\n      tempSocket.close(1000);\n      this.awsRealTimeSocket = undefined;\n      this.socketStatus = SOCKET_STATUS.CLOSED;\n      this.connectionStateMonitor.record(CONNECTION_CHANGE.CLOSED);\n    }\n  }\n  _handleIncomingSubscriptionMessage(message) {\n    if (typeof message.data !== 'string') {\n      return;\n    }\n    logger.debug(`subscription message from AWS AppSync RealTime: ${message.data}`);\n    const {\n      id = '',\n      payload,\n      type\n    } = JSON.parse(String(message.data));\n    const {\n      observer = null,\n      query = '',\n      variables = {},\n      startAckTimeoutId,\n      subscriptionReadyCallback,\n      subscriptionFailedCallback\n    } = this.subscriptionObserverMap.get(id) || {};\n    logger.debug({\n      id,\n      observer,\n      query,\n      variables\n    });\n    if (type === MESSAGE_TYPES.GQL_DATA && payload && payload.data) {\n      if (observer) {\n        observer.next(payload);\n      } else {\n        logger.debug(`observer not found for id: ${id}`);\n      }\n      return;\n    }\n    if (type === MESSAGE_TYPES.GQL_START_ACK) {\n      logger.debug(`subscription ready for ${JSON.stringify({\n        query,\n        variables\n      })}`);\n      if (typeof subscriptionReadyCallback === 'function') {\n        subscriptionReadyCallback();\n      }\n      if (startAckTimeoutId) clearTimeout(startAckTimeoutId);\n      dispatchApiEvent({\n        event: CONTROL_MSG.SUBSCRIPTION_ACK,\n        data: {\n          query,\n          variables\n        },\n        message: 'Connection established for subscription'\n      });\n      const subscriptionState = SUBSCRIPTION_STATUS.CONNECTED;\n      if (observer) {\n        this.subscriptionObserverMap.set(id, {\n          observer,\n          query,\n          variables,\n          startAckTimeoutId: undefined,\n          subscriptionState,\n          subscriptionReadyCallback,\n          subscriptionFailedCallback\n        });\n      }\n      this.connectionStateMonitor.record(CONNECTION_CHANGE.CONNECTION_ESTABLISHED);\n      return;\n    }\n    if (type === MESSAGE_TYPES.GQL_CONNECTION_KEEP_ALIVE) {\n      if (this.keepAliveTimeoutId) clearTimeout(this.keepAliveTimeoutId);\n      if (this.keepAliveAlertTimeoutId) clearTimeout(this.keepAliveAlertTimeoutId);\n      this.keepAliveTimeoutId = setTimeout(() => {\n        this._errorDisconnect(CONTROL_MSG.TIMEOUT_DISCONNECT);\n      }, this.keepAliveTimeout);\n      this.keepAliveAlertTimeoutId = setTimeout(() => {\n        this.connectionStateMonitor.record(CONNECTION_CHANGE.KEEP_ALIVE_MISSED);\n      }, DEFAULT_KEEP_ALIVE_ALERT_TIMEOUT);\n      this.connectionStateMonitor.record(CONNECTION_CHANGE.KEEP_ALIVE);\n      return;\n    }\n    if (type === MESSAGE_TYPES.GQL_ERROR) {\n      const subscriptionState = SUBSCRIPTION_STATUS.FAILED;\n      if (observer) {\n        this.subscriptionObserverMap.set(id, {\n          observer,\n          query,\n          variables,\n          startAckTimeoutId,\n          subscriptionReadyCallback,\n          subscriptionFailedCallback,\n          subscriptionState\n        });\n        logger.debug(`${CONTROL_MSG.CONNECTION_FAILED}: ${JSON.stringify(payload)}`);\n        observer.error({\n          errors: [{\n            ...new GraphQLError(`${CONTROL_MSG.CONNECTION_FAILED}: ${JSON.stringify(payload)}`)\n          }]\n        });\n        if (startAckTimeoutId) clearTimeout(startAckTimeoutId);\n        if (typeof subscriptionFailedCallback === 'function') {\n          subscriptionFailedCallback();\n        }\n      }\n    }\n  }\n  _errorDisconnect(msg) {\n    logger.debug(`Disconnect error: ${msg}`);\n    if (this.awsRealTimeSocket) {\n      this.connectionStateMonitor.record(CONNECTION_CHANGE.CLOSED);\n      this.awsRealTimeSocket.close();\n    }\n    this.socketStatus = SOCKET_STATUS.CLOSED;\n  }\n  _timeoutStartSubscriptionAck(subscriptionId) {\n    const subscriptionObserver = this.subscriptionObserverMap.get(subscriptionId);\n    if (subscriptionObserver) {\n      const {\n        observer,\n        query,\n        variables\n      } = subscriptionObserver;\n      if (!observer) {\n        return;\n      }\n      this.subscriptionObserverMap.set(subscriptionId, {\n        observer,\n        query,\n        variables,\n        subscriptionState: SUBSCRIPTION_STATUS.FAILED\n      });\n      this.connectionStateMonitor.record(CONNECTION_CHANGE.CLOSED);\n      logger.debug('timeoutStartSubscription', JSON.stringify({\n        query,\n        variables\n      }));\n    }\n  }\n  /**\n   * Strips out `Authorization` header if present\n   */\n  _extractNonAuthHeaders(headers) {\n    if (!headers) {\n      return {};\n    }\n    if ('Authorization' in headers) {\n      const {\n        Authorization: _,\n        ...nonAuthHeaders\n      } = headers;\n      return nonAuthHeaders;\n    }\n    return headers;\n  }\n  /**\n   *\n   * @param headers - http headers\n   * @returns uri-encoded query parameters derived from custom headers\n   */\n  _queryParamsFromCustomHeaders(headers) {\n    const nonAuthHeaders = this._extractNonAuthHeaders(headers);\n    const params = new AmplifyUrlSearchParams();\n    Object.entries(nonAuthHeaders).forEach(([k, v]) => {\n      params.append(k, v);\n    });\n    return params;\n  }\n  /**\n   * Normalizes AppSync realtime endpoint URL\n   *\n   * @param appSyncGraphqlEndpoint - AppSync endpointUri from config\n   * @param urlParams - URLSearchParams\n   * @returns fully resolved string realtime endpoint URL\n   */\n  _realtimeUrlWithQueryString(appSyncGraphqlEndpoint, urlParams) {\n    const protocol = 'wss://';\n    let realtimeEndpoint = appSyncGraphqlEndpoint ?? '';\n    if (this.isCustomDomain(realtimeEndpoint)) {\n      realtimeEndpoint = realtimeEndpoint.concat(customDomainPath);\n    } else {\n      realtimeEndpoint = realtimeEndpoint.replace('appsync-api', 'appsync-realtime-api').replace('gogi-beta', 'grt-beta');\n    }\n    realtimeEndpoint = realtimeEndpoint.replace('https://', protocol).replace('http://', protocol);\n    const realtimeEndpointUrl = new AmplifyUrl(realtimeEndpoint);\n    // preserves any query params a customer might manually set in the configuration\n    const existingParams = new AmplifyUrlSearchParams(realtimeEndpointUrl.search);\n    for (const [k, v] of urlParams.entries()) {\n      existingParams.append(k, v);\n    }\n    realtimeEndpointUrl.search = existingParams.toString();\n    return realtimeEndpointUrl.toString();\n  }\n  _initializeWebSocketConnection({\n    appSyncGraphqlEndpoint,\n    authenticationType,\n    apiKey,\n    region,\n    additionalCustomHeaders\n  }) {\n    if (this.socketStatus === SOCKET_STATUS.READY) {\n      return;\n    }\n    // TODO(Eslint): refactor to now use async function as the promise executor\n    // eslint-disable-next-line no-async-promise-executor\n    return new Promise(async (resolve, reject) => {\n      this.promiseArray.push({\n        res: resolve,\n        rej: reject\n      });\n      if (this.socketStatus === SOCKET_STATUS.CLOSED) {\n        try {\n          this.socketStatus = SOCKET_STATUS.CONNECTING;\n          const payloadString = '{}';\n          const authHeader = await this._awsRealTimeHeaderBasedAuth({\n            authenticationType,\n            payload: payloadString,\n            canonicalUri: '/connect',\n            apiKey,\n            appSyncGraphqlEndpoint,\n            region,\n            additionalCustomHeaders\n          });\n          const headerString = authHeader ? JSON.stringify(authHeader) : '';\n          // base64url-encoded string\n          const encodedHeader = base64Encoder.convert(headerString, {\n            urlSafe: true,\n            skipPadding: true\n          });\n          const authTokenSubprotocol = `header-${encodedHeader}`;\n          const queryParams = this._queryParamsFromCustomHeaders(additionalCustomHeaders);\n          const awsRealTimeUrl = this._realtimeUrlWithQueryString(appSyncGraphqlEndpoint, queryParams);\n          await this._initializeRetryableHandshake(awsRealTimeUrl, authTokenSubprotocol);\n          this.promiseArray.forEach(({\n            res\n          }) => {\n            logger.debug('Notifying connection successful');\n            res();\n          });\n          this.socketStatus = SOCKET_STATUS.READY;\n          this.promiseArray = [];\n        } catch (err) {\n          logger.debug('Connection exited with', err);\n          this.promiseArray.forEach(({\n            rej\n          }) => {\n            rej(err);\n          });\n          this.promiseArray = [];\n          if (this.awsRealTimeSocket && this.awsRealTimeSocket.readyState === WebSocket.OPEN) {\n            this.awsRealTimeSocket.close(3001);\n          }\n          this.awsRealTimeSocket = undefined;\n          this.socketStatus = SOCKET_STATUS.CLOSED;\n        }\n      }\n    });\n  }\n  async _initializeRetryableHandshake(awsRealTimeUrl, subprotocol) {\n    logger.debug(`Initializaling retryable Handshake`);\n    await jitteredExponentialRetry(this._initializeHandshake.bind(this), [awsRealTimeUrl, subprotocol], MAX_DELAY_MS);\n  }\n  /**\n   *\n   * @param subprotocol -\n   */\n  async _initializeHandshake(awsRealTimeUrl, subprotocol) {\n    logger.debug(`Initializing handshake ${awsRealTimeUrl}`);\n    // Because connecting the socket is async, is waiting until connection is open\n    // Step 1: connect websocket\n    try {\n      await (() => {\n        return new Promise((resolve, reject) => {\n          const newSocket = this.getNewWebSocket(awsRealTimeUrl, ['graphql-ws', subprotocol]);\n          newSocket.onerror = () => {\n            logger.debug(`WebSocket connection error`);\n          };\n          newSocket.onclose = () => {\n            reject(new Error('Connection handshake error'));\n          };\n          newSocket.onopen = () => {\n            this.awsRealTimeSocket = newSocket;\n            resolve();\n          };\n        });\n      })();\n      // Step 2: wait for ack from AWS AppSyncReaTime after sending init\n      await (() => {\n        return new Promise((resolve, reject) => {\n          if (this.awsRealTimeSocket) {\n            let ackOk = false;\n            this.awsRealTimeSocket.onerror = error => {\n              logger.debug(`WebSocket error ${JSON.stringify(error)}`);\n            };\n            this.awsRealTimeSocket.onclose = event => {\n              logger.debug(`WebSocket closed ${event.reason}`);\n              reject(new Error(JSON.stringify(event)));\n            };\n            this.awsRealTimeSocket.onmessage = message => {\n              if (typeof message.data !== 'string') {\n                return;\n              }\n              logger.debug(`subscription message from AWS AppSyncRealTime: ${message.data} `);\n              const data = JSON.parse(message.data);\n              const {\n                type,\n                payload: {\n                  connectionTimeoutMs = DEFAULT_KEEP_ALIVE_TIMEOUT\n                } = {}\n              } = data;\n              if (type === MESSAGE_TYPES.GQL_CONNECTION_ACK) {\n                ackOk = true;\n                if (this.awsRealTimeSocket) {\n                  this.keepAliveTimeout = connectionTimeoutMs;\n                  this.awsRealTimeSocket.onmessage = this._handleIncomingSubscriptionMessage.bind(this);\n                  this.awsRealTimeSocket.onerror = err => {\n                    logger.debug(err);\n                    this._errorDisconnect(CONTROL_MSG.CONNECTION_CLOSED);\n                  };\n                  this.awsRealTimeSocket.onclose = event => {\n                    logger.debug(`WebSocket closed ${event.reason}`);\n                    this._errorDisconnect(CONTROL_MSG.CONNECTION_CLOSED);\n                  };\n                }\n                resolve('Cool, connected to AWS AppSyncRealTime');\n                return;\n              }\n              if (type === MESSAGE_TYPES.GQL_CONNECTION_ERROR) {\n                const {\n                  payload: {\n                    errors: [{\n                      errorType = '',\n                      errorCode = 0\n                    } = {}] = []\n                  } = {}\n                } = data;\n                // TODO(Eslint): refactor to reject an Error object instead of a plain object\n                // eslint-disable-next-line prefer-promise-reject-errors\n                reject({\n                  errorType,\n                  errorCode\n                });\n              }\n            };\n            const gqlInit = {\n              type: MESSAGE_TYPES.GQL_CONNECTION_INIT\n            };\n            this.awsRealTimeSocket.send(JSON.stringify(gqlInit));\n            const checkAckOk = targetAckOk => {\n              if (!targetAckOk) {\n                this.connectionStateMonitor.record(CONNECTION_CHANGE.CONNECTION_FAILED);\n                reject(new Error(`Connection timeout: ack from AWSAppSyncRealTime was not received after ${CONNECTION_INIT_TIMEOUT} ms`));\n              }\n            };\n            setTimeout(() => {\n              checkAckOk(ackOk);\n            }, CONNECTION_INIT_TIMEOUT);\n          }\n        });\n      })();\n    } catch (err) {\n      const {\n        errorType,\n        errorCode\n      } = err;\n      if (NON_RETRYABLE_CODES.includes(errorCode)) {\n        throw new NonRetryableError(errorType);\n      } else if (errorType) {\n        throw new Error(errorType);\n      } else {\n        throw err;\n      }\n    }\n  }\n  async _awsRealTimeHeaderBasedAuth({\n    apiKey,\n    authenticationType,\n    payload,\n    canonicalUri,\n    appSyncGraphqlEndpoint,\n    region,\n    additionalCustomHeaders\n  }) {\n    const headerHandler = {\n      apiKey: this._awsRealTimeApiKeyHeader.bind(this),\n      iam: this._awsRealTimeIAMHeader.bind(this),\n      oidc: this._awsAuthTokenHeader.bind(this),\n      userPool: this._awsAuthTokenHeader.bind(this),\n      lambda: this._customAuthHeader,\n      none: this._customAuthHeader\n    };\n    if (!authenticationType || !headerHandler[authenticationType]) {\n      logger.debug(`Authentication type ${authenticationType} not supported`);\n      return undefined;\n    } else {\n      const handler = headerHandler[authenticationType];\n      const host = appSyncGraphqlEndpoint ? new AmplifyUrl(appSyncGraphqlEndpoint).host : undefined;\n      logger.debug(`Authenticating with ${JSON.stringify(authenticationType)}`);\n      let resolvedApiKey;\n      if (authenticationType === 'apiKey') {\n        resolvedApiKey = apiKey;\n      }\n      const result = await handler({\n        payload,\n        canonicalUri,\n        appSyncGraphqlEndpoint,\n        apiKey: resolvedApiKey,\n        region,\n        host,\n        additionalCustomHeaders\n      });\n      return result;\n    }\n  }\n  async _awsAuthTokenHeader({\n    host\n  }) {\n    const session = await fetchAuthSession();\n    return {\n      Authorization: session?.tokens?.accessToken?.toString(),\n      host\n    };\n  }\n  async _awsRealTimeApiKeyHeader({\n    apiKey,\n    host\n  }) {\n    const dt = new Date();\n    const dtStr = dt.toISOString().replace(/[:-]|\\.\\d{3}/g, '');\n    return {\n      host,\n      'x-amz-date': dtStr,\n      'x-api-key': apiKey\n    };\n  }\n  async _awsRealTimeIAMHeader({\n    payload,\n    canonicalUri,\n    appSyncGraphqlEndpoint,\n    region\n  }) {\n    const endpointInfo = {\n      region,\n      service: 'appsync'\n    };\n    const creds = (await fetchAuthSession()).credentials;\n    const request = {\n      url: `${appSyncGraphqlEndpoint}${canonicalUri}`,\n      data: payload,\n      method: 'POST',\n      headers: {\n        ...AWS_APPSYNC_REALTIME_HEADERS\n      }\n    };\n    const signedParams = signRequest({\n      headers: request.headers,\n      method: request.method,\n      url: new AmplifyUrl(request.url),\n      body: request.data\n    }, {\n      // TODO: What do we need to do to remove these !'s?\n      credentials: creds,\n      signingRegion: endpointInfo.region,\n      signingService: endpointInfo.service\n    });\n    return signedParams.headers;\n  }\n  _customAuthHeader({\n    host,\n    additionalCustomHeaders\n  }) {\n    /**\n     * If `additionalHeaders` was provided to the subscription as a function,\n     * the headers that are returned by that function will already have been\n     * provided before this function is called.\n     */\n    if (!additionalCustomHeaders?.Authorization) {\n      throw new Error('No auth token specified');\n    }\n    return {\n      Authorization: additionalCustomHeaders.Authorization,\n      host\n    };\n  }\n}\nexport { AWSAppSyncRealTimeProvider };","map":{"version":3,"names":["logger","ConsoleLogger","dispatchApiEvent","payload","Hub","dispatch","AMPLIFY_SYMBOL","standardDomainPattern","customDomainPath","AWSAppSyncRealTimeProvider","constructor","socketStatus","SOCKET_STATUS","CLOSED","keepAliveTimeout","DEFAULT_KEEP_ALIVE_TIMEOUT","subscriptionObserverMap","Map","promiseArray","connectionStateMonitor","ConnectionStateMonitor","reconnectionMonitor","ReconnectionMonitor","connectionStateMonitorSubscription","connectionStateObservable","subscribe","connectionState","event","CONNECTION_STATE_CHANGE","data","provider","message","ConnectionState","ConnectionDisrupted","record","ReconnectEvent","START_RECONNECT","Connected","ConnectedPendingDisconnect","ConnectedPendingKeepAlive","ConnectedPendingNetwork","ConnectionDisruptedPendingNetwork","Disconnected","includes","HALT_RECONNECT","close","CONNECTION_CHANGE","CONNECTION_FAILED","unsubscribe","getNewWebSocket","url","protocol","WebSocket","getProviderName","isCustomDomain","match","options","customUserAgentDetails","appSyncGraphqlEndpoint","region","query","variables","authenticationType","additionalHeaders","apiKey","authToken","libraryConfigHeaders","Observable","observer","error","errors","GraphQLError","complete","subscriptionStartActive","subscriptionId","amplifyUuid","startSubscription","startSubscriptionPromise","_startSubscriptionWithAWSAppSyncRealTime","catch","err","debug","CONTROL_MSG","REALTIME_SUBSCRIPTION_INIT_ERROR","finally","reconnectSubscription","reconnectSubscriptionObserver","addObserver","_waitForSubscriptionToBeConnected","subscriptionState","get","SUBSCRIPTION_STATUS","CONNECTED","_sendUnsubscriptionMessage","Error","_removeSubscriptionObserver","additionalCustomHeaders","requestOptions","queryString","Authorization","PENDING","set","startAckTimeoutId","undefined","dataString","JSON","stringify","headerObj","_awsRealTimeHeaderBasedAuth","canonicalUri","USER_AGENT_HEADER","getAmplifyUserAgent","subscriptionMessage","id","extensions","authorization","type","MESSAGE_TYPES","GQL_START","stringToAWSRealTime","OPENING_CONNECTION","_initializeWebSocketConnection","_logStartSubscriptionError","subscriptionFailedCallback","subscriptionReadyCallback","setTimeout","_timeoutStartSubscriptionAck","START_ACK_TIMEOUT","awsRealTimeSocket","send","String","isNonRetryableError","subscriptionObserver","Promise","resolve","reject","observedSubscriptionState","readyState","OPEN","READY","unsubscribeMessage","GQL_STOP","delete","_closeSocketIfRequired","bind","size","CLOSING_CONNECTION","bufferedAmount","keepAliveTimeoutId","clearTimeout","keepAliveAlertTimeoutId","tempSocket","onclose","onerror","_handleIncomingSubscriptionMessage","parse","GQL_DATA","next","GQL_START_ACK","SUBSCRIPTION_ACK","CONNECTION_ESTABLISHED","GQL_CONNECTION_KEEP_ALIVE","_errorDisconnect","TIMEOUT_DISCONNECT","KEEP_ALIVE_MISSED","DEFAULT_KEEP_ALIVE_ALERT_TIMEOUT","KEEP_ALIVE","GQL_ERROR","FAILED","msg","_extractNonAuthHeaders","headers","_","nonAuthHeaders","_queryParamsFromCustomHeaders","params","AmplifyUrlSearchParams","Object","entries","forEach","k","v","append","_realtimeUrlWithQueryString","urlParams","realtimeEndpoint","concat","replace","realtimeEndpointUrl","AmplifyUrl","existingParams","search","toString","push","res","rej","CONNECTING","payloadString","authHeader","headerString","encodedHeader","base64Encoder","convert","urlSafe","skipPadding","authTokenSubprotocol","queryParams","awsRealTimeUrl","_initializeRetryableHandshake","subprotocol","jitteredExponentialRetry","_initializeHandshake","MAX_DELAY_MS","newSocket","onopen","ackOk","reason","onmessage","connectionTimeoutMs","GQL_CONNECTION_ACK","CONNECTION_CLOSED","GQL_CONNECTION_ERROR","errorType","errorCode","gqlInit","GQL_CONNECTION_INIT","checkAckOk","targetAckOk","CONNECTION_INIT_TIMEOUT","NON_RETRYABLE_CODES","NonRetryableError","headerHandler","_awsRealTimeApiKeyHeader","iam","_awsRealTimeIAMHeader","oidc","_awsAuthTokenHeader","userPool","lambda","_customAuthHeader","none","handler","host","resolvedApiKey","result","session","fetchAuthSession","tokens","accessToken","dt","Date","dtStr","toISOString","endpointInfo","service","creds","credentials","request","method","AWS_APPSYNC_REALTIME_HEADERS","signedParams","signRequest","body","signingRegion","signingService"],"sources":["../../../../src/Providers/AWSAppSyncRealTimeProvider/index.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { Observable } from 'rxjs';\nimport { GraphQLError } from 'graphql';\nimport { ConsoleLogger, Hub, fetchAuthSession, } from '@aws-amplify/core';\nimport { signRequest } from '@aws-amplify/core/internals/aws-client-utils';\nimport { AmplifyUrl, AmplifyUrlSearchParams, NonRetryableError, USER_AGENT_HEADER, amplifyUuid, base64Encoder, getAmplifyUserAgent, isNonRetryableError, jitteredExponentialRetry, } from '@aws-amplify/core/internals/utils';\nimport { CONTROL_MSG, ConnectionState, } from '../../types/PubSub';\nimport { AMPLIFY_SYMBOL, AWS_APPSYNC_REALTIME_HEADERS, CONNECTION_INIT_TIMEOUT, CONNECTION_STATE_CHANGE, DEFAULT_KEEP_ALIVE_ALERT_TIMEOUT, DEFAULT_KEEP_ALIVE_TIMEOUT, MAX_DELAY_MS, MESSAGE_TYPES, NON_RETRYABLE_CODES, SOCKET_STATUS, START_ACK_TIMEOUT, SUBSCRIPTION_STATUS, } from '../constants';\nimport { CONNECTION_CHANGE, ConnectionStateMonitor, } from '../../utils/ConnectionStateMonitor';\nimport { ReconnectEvent, ReconnectionMonitor, } from '../../utils/ReconnectionMonitor';\nconst logger = new ConsoleLogger('AWSAppSyncRealTimeProvider');\nconst dispatchApiEvent = (payload) => {\n    Hub.dispatch('api', payload, 'PubSub', AMPLIFY_SYMBOL);\n};\nconst standardDomainPattern = /^https:\\/\\/\\w{26}\\.appsync-api\\.\\w{2}(?:(?:-\\w{2,})+)-\\d\\.amazonaws.com(?:\\.cn)?\\/graphql$/i;\nconst customDomainPath = '/realtime';\nexport class AWSAppSyncRealTimeProvider {\n    constructor() {\n        this.socketStatus = SOCKET_STATUS.CLOSED;\n        this.keepAliveTimeout = DEFAULT_KEEP_ALIVE_TIMEOUT;\n        this.subscriptionObserverMap = new Map();\n        this.promiseArray = [];\n        this.connectionStateMonitor = new ConnectionStateMonitor();\n        this.reconnectionMonitor = new ReconnectionMonitor();\n        // Monitor the connection state and pass changes along to Hub\n        this.connectionStateMonitorSubscription =\n            this.connectionStateMonitor.connectionStateObservable.subscribe(connectionState => {\n                dispatchApiEvent({\n                    event: CONNECTION_STATE_CHANGE,\n                    data: {\n                        provider: this,\n                        connectionState,\n                    },\n                    message: `Connection state is ${connectionState}`,\n                });\n                this.connectionState = connectionState;\n                // Trigger START_RECONNECT when the connection is disrupted\n                if (connectionState === ConnectionState.ConnectionDisrupted) {\n                    this.reconnectionMonitor.record(ReconnectEvent.START_RECONNECT);\n                }\n                // Trigger HALT_RECONNECT to halt reconnection attempts when the state is anything other than\n                //   ConnectionDisrupted or Connecting\n                if ([\n                    ConnectionState.Connected,\n                    ConnectionState.ConnectedPendingDisconnect,\n                    ConnectionState.ConnectedPendingKeepAlive,\n                    ConnectionState.ConnectedPendingNetwork,\n                    ConnectionState.ConnectionDisruptedPendingNetwork,\n                    ConnectionState.Disconnected,\n                ].includes(connectionState)) {\n                    this.reconnectionMonitor.record(ReconnectEvent.HALT_RECONNECT);\n                }\n            });\n    }\n    /**\n     * Mark the socket closed and release all active listeners\n     */\n    close() {\n        // Mark the socket closed both in status and the connection monitor\n        this.socketStatus = SOCKET_STATUS.CLOSED;\n        this.connectionStateMonitor.record(CONNECTION_CHANGE.CONNECTION_FAILED);\n        // Turn off the subscription monitor Hub publishing\n        this.connectionStateMonitorSubscription.unsubscribe();\n        // Complete all reconnect observers\n        this.reconnectionMonitor.close();\n    }\n    getNewWebSocket(url, protocol) {\n        return new WebSocket(url, protocol);\n    }\n    getProviderName() {\n        return 'AWSAppSyncRealTimeProvider';\n    }\n    // Check if url matches standard domain pattern\n    isCustomDomain(url) {\n        return url.match(standardDomainPattern) === null;\n    }\n    subscribe(options, customUserAgentDetails) {\n        const { appSyncGraphqlEndpoint, region, query, variables, authenticationType, additionalHeaders, apiKey, authToken, libraryConfigHeaders, } = options || {};\n        return new Observable(observer => {\n            if (!options || !appSyncGraphqlEndpoint) {\n                observer.error({\n                    errors: [\n                        {\n                            ...new GraphQLError(`Subscribe only available for AWS AppSync endpoint`),\n                        },\n                    ],\n                });\n                observer.complete();\n            }\n            else {\n                let subscriptionStartActive = false;\n                const subscriptionId = amplifyUuid();\n                const startSubscription = () => {\n                    if (!subscriptionStartActive) {\n                        subscriptionStartActive = true;\n                        const startSubscriptionPromise = this._startSubscriptionWithAWSAppSyncRealTime({\n                            options: {\n                                query,\n                                variables,\n                                region,\n                                authenticationType,\n                                appSyncGraphqlEndpoint,\n                                additionalHeaders,\n                                apiKey,\n                                authToken,\n                                libraryConfigHeaders,\n                            },\n                            observer,\n                            subscriptionId,\n                            customUserAgentDetails,\n                        }).catch(err => {\n                            logger.debug(`${CONTROL_MSG.REALTIME_SUBSCRIPTION_INIT_ERROR}: ${err}`);\n                            this.connectionStateMonitor.record(CONNECTION_CHANGE.CLOSED);\n                        });\n                        startSubscriptionPromise.finally(() => {\n                            subscriptionStartActive = false;\n                        });\n                    }\n                };\n                // Add an observable to the reconnection list to manage reconnection for this subscription\n                const reconnectSubscription = new Observable(reconnectSubscriptionObserver => {\n                    this.reconnectionMonitor.addObserver(reconnectSubscriptionObserver);\n                }).subscribe(() => {\n                    startSubscription();\n                });\n                startSubscription();\n                return async () => {\n                    // Cleanup reconnection subscription\n                    reconnectSubscription?.unsubscribe();\n                    // Cleanup after unsubscribing or observer.complete was called after _startSubscriptionWithAWSAppSyncRealTime\n                    try {\n                        // Waiting that subscription has been connected before trying to unsubscribe\n                        await this._waitForSubscriptionToBeConnected(subscriptionId);\n                        const { subscriptionState } = this.subscriptionObserverMap.get(subscriptionId) || {};\n                        if (!subscriptionState) {\n                            // subscription already unsubscribed\n                            return;\n                        }\n                        if (subscriptionState === SUBSCRIPTION_STATUS.CONNECTED) {\n                            this._sendUnsubscriptionMessage(subscriptionId);\n                        }\n                        else {\n                            throw new Error('Subscription never connected');\n                        }\n                    }\n                    catch (err) {\n                        logger.debug(`Error while unsubscribing ${err}`);\n                    }\n                    finally {\n                        this._removeSubscriptionObserver(subscriptionId);\n                    }\n                };\n            }\n        });\n    }\n    async _startSubscriptionWithAWSAppSyncRealTime({ options, observer, subscriptionId, customUserAgentDetails, }) {\n        const { appSyncGraphqlEndpoint, authenticationType, query, variables, apiKey, region, libraryConfigHeaders = () => ({}), additionalHeaders = {}, authToken, } = options;\n        let additionalCustomHeaders = {};\n        if (typeof additionalHeaders === 'function') {\n            const requestOptions = {\n                url: appSyncGraphqlEndpoint || '',\n                queryString: query || '',\n            };\n            additionalCustomHeaders = await additionalHeaders(requestOptions);\n        }\n        else {\n            additionalCustomHeaders = additionalHeaders;\n        }\n        // if an authorization header is set, have the explicit authToken take precedence\n        if (authToken) {\n            additionalCustomHeaders = {\n                ...additionalCustomHeaders,\n                Authorization: authToken,\n            };\n        }\n        const subscriptionState = SUBSCRIPTION_STATUS.PENDING;\n        const data = {\n            query,\n            variables,\n        };\n        // Having a subscription id map will make it simple to forward messages received\n        this.subscriptionObserverMap.set(subscriptionId, {\n            observer,\n            query: query ?? '',\n            variables: variables ?? {},\n            subscriptionState,\n            startAckTimeoutId: undefined,\n        });\n        // Preparing payload for subscription message\n        const dataString = JSON.stringify(data);\n        const headerObj = {\n            ...(await this._awsRealTimeHeaderBasedAuth({\n                apiKey,\n                appSyncGraphqlEndpoint,\n                authenticationType,\n                payload: dataString,\n                canonicalUri: '',\n                region,\n                additionalCustomHeaders,\n            })),\n            ...(await libraryConfigHeaders()),\n            ...additionalCustomHeaders,\n            [USER_AGENT_HEADER]: getAmplifyUserAgent(customUserAgentDetails),\n        };\n        const subscriptionMessage = {\n            id: subscriptionId,\n            payload: {\n                data: dataString,\n                extensions: {\n                    authorization: {\n                        ...headerObj,\n                    },\n                },\n            },\n            type: MESSAGE_TYPES.GQL_START,\n        };\n        const stringToAWSRealTime = JSON.stringify(subscriptionMessage);\n        try {\n            this.connectionStateMonitor.record(CONNECTION_CHANGE.OPENING_CONNECTION);\n            await this._initializeWebSocketConnection({\n                apiKey,\n                appSyncGraphqlEndpoint,\n                authenticationType,\n                region,\n                additionalCustomHeaders,\n            });\n        }\n        catch (err) {\n            this._logStartSubscriptionError(subscriptionId, observer, err);\n            return;\n        }\n        // Potential race condition can occur when unsubscribe is called during _initializeWebSocketConnection.\n        // E.g.unsubscribe gets invoked prior to finishing WebSocket handshake or START_ACK.\n        // Both subscriptionFailedCallback and subscriptionReadyCallback are used to synchronized this.\n        const { subscriptionFailedCallback, subscriptionReadyCallback } = this.subscriptionObserverMap.get(subscriptionId) ?? {};\n        // This must be done before sending the message in order to be listening immediately\n        this.subscriptionObserverMap.set(subscriptionId, {\n            observer,\n            subscriptionState,\n            query: query ?? '',\n            variables: variables ?? {},\n            subscriptionReadyCallback,\n            subscriptionFailedCallback,\n            startAckTimeoutId: setTimeout(() => {\n                this._timeoutStartSubscriptionAck(subscriptionId);\n            }, START_ACK_TIMEOUT),\n        });\n        if (this.awsRealTimeSocket) {\n            this.awsRealTimeSocket.send(stringToAWSRealTime);\n        }\n    }\n    // Log logic for start subscription failures\n    _logStartSubscriptionError(subscriptionId, observer, err) {\n        logger.debug({ err });\n        const message = String(err.message ?? '');\n        // Resolving to give the state observer time to propogate the update\n        this.connectionStateMonitor.record(CONNECTION_CHANGE.CLOSED);\n        // Capture the error only when the network didn't cause disruption\n        if (this.connectionState !== ConnectionState.ConnectionDisruptedPendingNetwork) {\n            // When the error is non-retriable, error out the observable\n            if (isNonRetryableError(err)) {\n                observer.error({\n                    errors: [\n                        {\n                            ...new GraphQLError(`${CONTROL_MSG.CONNECTION_FAILED}: ${message}`),\n                        },\n                    ],\n                });\n            }\n            else {\n                logger.debug(`${CONTROL_MSG.CONNECTION_FAILED}: ${message}`);\n            }\n            const { subscriptionFailedCallback } = this.subscriptionObserverMap.get(subscriptionId) || {};\n            // Notify concurrent unsubscription\n            if (typeof subscriptionFailedCallback === 'function') {\n                subscriptionFailedCallback();\n            }\n        }\n    }\n    // Waiting that subscription has been connected before trying to unsubscribe\n    async _waitForSubscriptionToBeConnected(subscriptionId) {\n        const subscriptionObserver = this.subscriptionObserverMap.get(subscriptionId);\n        if (subscriptionObserver) {\n            const { subscriptionState } = subscriptionObserver;\n            // This in case unsubscribe is invoked before sending start subscription message\n            if (subscriptionState === SUBSCRIPTION_STATUS.PENDING) {\n                return new Promise((resolve, reject) => {\n                    const { observer, subscriptionState: observedSubscriptionState, variables, query, } = subscriptionObserver;\n                    this.subscriptionObserverMap.set(subscriptionId, {\n                        observer,\n                        subscriptionState: observedSubscriptionState,\n                        variables,\n                        query,\n                        subscriptionReadyCallback: resolve,\n                        subscriptionFailedCallback: reject,\n                    });\n                });\n            }\n        }\n    }\n    _sendUnsubscriptionMessage(subscriptionId) {\n        try {\n            if (this.awsRealTimeSocket &&\n                this.awsRealTimeSocket.readyState === WebSocket.OPEN &&\n                this.socketStatus === SOCKET_STATUS.READY) {\n                // Preparing unsubscribe message to stop receiving messages for that subscription\n                const unsubscribeMessage = {\n                    id: subscriptionId,\n                    type: MESSAGE_TYPES.GQL_STOP,\n                };\n                const stringToAWSRealTime = JSON.stringify(unsubscribeMessage);\n                this.awsRealTimeSocket.send(stringToAWSRealTime);\n            }\n        }\n        catch (err) {\n            // If GQL_STOP is not sent because of disconnection issue, then there is nothing the client can do\n            logger.debug({ err });\n        }\n    }\n    _removeSubscriptionObserver(subscriptionId) {\n        this.subscriptionObserverMap.delete(subscriptionId);\n        // Verifying 1000ms after removing subscription in case there are new subscription unmount/mount\n        setTimeout(this._closeSocketIfRequired.bind(this), 1000);\n    }\n    _closeSocketIfRequired() {\n        if (this.subscriptionObserverMap.size > 0) {\n            // Active subscriptions on the WebSocket\n            return;\n        }\n        if (!this.awsRealTimeSocket) {\n            this.socketStatus = SOCKET_STATUS.CLOSED;\n            return;\n        }\n        this.connectionStateMonitor.record(CONNECTION_CHANGE.CLOSING_CONNECTION);\n        if (this.awsRealTimeSocket.bufferedAmount > 0) {\n            // Still data on the WebSocket\n            setTimeout(this._closeSocketIfRequired.bind(this), 1000);\n        }\n        else {\n            logger.debug('closing WebSocket...');\n            if (this.keepAliveTimeoutId) {\n                clearTimeout(this.keepAliveTimeoutId);\n            }\n            if (this.keepAliveAlertTimeoutId) {\n                clearTimeout(this.keepAliveAlertTimeoutId);\n            }\n            const tempSocket = this.awsRealTimeSocket;\n            // Cleaning callbacks to avoid race condition, socket still exists\n            tempSocket.onclose = null;\n            tempSocket.onerror = null;\n            tempSocket.close(1000);\n            this.awsRealTimeSocket = undefined;\n            this.socketStatus = SOCKET_STATUS.CLOSED;\n            this.connectionStateMonitor.record(CONNECTION_CHANGE.CLOSED);\n        }\n    }\n    _handleIncomingSubscriptionMessage(message) {\n        if (typeof message.data !== 'string') {\n            return;\n        }\n        logger.debug(`subscription message from AWS AppSync RealTime: ${message.data}`);\n        const { id = '', payload, type, } = JSON.parse(String(message.data));\n        const { observer = null, query = '', variables = {}, startAckTimeoutId, subscriptionReadyCallback, subscriptionFailedCallback, } = this.subscriptionObserverMap.get(id) || {};\n        logger.debug({ id, observer, query, variables });\n        if (type === MESSAGE_TYPES.GQL_DATA && payload && payload.data) {\n            if (observer) {\n                observer.next(payload);\n            }\n            else {\n                logger.debug(`observer not found for id: ${id}`);\n            }\n            return;\n        }\n        if (type === MESSAGE_TYPES.GQL_START_ACK) {\n            logger.debug(`subscription ready for ${JSON.stringify({ query, variables })}`);\n            if (typeof subscriptionReadyCallback === 'function') {\n                subscriptionReadyCallback();\n            }\n            if (startAckTimeoutId)\n                clearTimeout(startAckTimeoutId);\n            dispatchApiEvent({\n                event: CONTROL_MSG.SUBSCRIPTION_ACK,\n                data: { query, variables },\n                message: 'Connection established for subscription',\n            });\n            const subscriptionState = SUBSCRIPTION_STATUS.CONNECTED;\n            if (observer) {\n                this.subscriptionObserverMap.set(id, {\n                    observer,\n                    query,\n                    variables,\n                    startAckTimeoutId: undefined,\n                    subscriptionState,\n                    subscriptionReadyCallback,\n                    subscriptionFailedCallback,\n                });\n            }\n            this.connectionStateMonitor.record(CONNECTION_CHANGE.CONNECTION_ESTABLISHED);\n            return;\n        }\n        if (type === MESSAGE_TYPES.GQL_CONNECTION_KEEP_ALIVE) {\n            if (this.keepAliveTimeoutId)\n                clearTimeout(this.keepAliveTimeoutId);\n            if (this.keepAliveAlertTimeoutId)\n                clearTimeout(this.keepAliveAlertTimeoutId);\n            this.keepAliveTimeoutId = setTimeout(() => {\n                this._errorDisconnect(CONTROL_MSG.TIMEOUT_DISCONNECT);\n            }, this.keepAliveTimeout);\n            this.keepAliveAlertTimeoutId = setTimeout(() => {\n                this.connectionStateMonitor.record(CONNECTION_CHANGE.KEEP_ALIVE_MISSED);\n            }, DEFAULT_KEEP_ALIVE_ALERT_TIMEOUT);\n            this.connectionStateMonitor.record(CONNECTION_CHANGE.KEEP_ALIVE);\n            return;\n        }\n        if (type === MESSAGE_TYPES.GQL_ERROR) {\n            const subscriptionState = SUBSCRIPTION_STATUS.FAILED;\n            if (observer) {\n                this.subscriptionObserverMap.set(id, {\n                    observer,\n                    query,\n                    variables,\n                    startAckTimeoutId,\n                    subscriptionReadyCallback,\n                    subscriptionFailedCallback,\n                    subscriptionState,\n                });\n                logger.debug(`${CONTROL_MSG.CONNECTION_FAILED}: ${JSON.stringify(payload)}`);\n                observer.error({\n                    errors: [\n                        {\n                            ...new GraphQLError(`${CONTROL_MSG.CONNECTION_FAILED}: ${JSON.stringify(payload)}`),\n                        },\n                    ],\n                });\n                if (startAckTimeoutId)\n                    clearTimeout(startAckTimeoutId);\n                if (typeof subscriptionFailedCallback === 'function') {\n                    subscriptionFailedCallback();\n                }\n            }\n        }\n    }\n    _errorDisconnect(msg) {\n        logger.debug(`Disconnect error: ${msg}`);\n        if (this.awsRealTimeSocket) {\n            this.connectionStateMonitor.record(CONNECTION_CHANGE.CLOSED);\n            this.awsRealTimeSocket.close();\n        }\n        this.socketStatus = SOCKET_STATUS.CLOSED;\n    }\n    _timeoutStartSubscriptionAck(subscriptionId) {\n        const subscriptionObserver = this.subscriptionObserverMap.get(subscriptionId);\n        if (subscriptionObserver) {\n            const { observer, query, variables } = subscriptionObserver;\n            if (!observer) {\n                return;\n            }\n            this.subscriptionObserverMap.set(subscriptionId, {\n                observer,\n                query,\n                variables,\n                subscriptionState: SUBSCRIPTION_STATUS.FAILED,\n            });\n            this.connectionStateMonitor.record(CONNECTION_CHANGE.CLOSED);\n            logger.debug('timeoutStartSubscription', JSON.stringify({ query, variables }));\n        }\n    }\n    /**\n     * Strips out `Authorization` header if present\n     */\n    _extractNonAuthHeaders(headers) {\n        if (!headers) {\n            return {};\n        }\n        if ('Authorization' in headers) {\n            const { Authorization: _, ...nonAuthHeaders } = headers;\n            return nonAuthHeaders;\n        }\n        return headers;\n    }\n    /**\n     *\n     * @param headers - http headers\n     * @returns uri-encoded query parameters derived from custom headers\n     */\n    _queryParamsFromCustomHeaders(headers) {\n        const nonAuthHeaders = this._extractNonAuthHeaders(headers);\n        const params = new AmplifyUrlSearchParams();\n        Object.entries(nonAuthHeaders).forEach(([k, v]) => {\n            params.append(k, v);\n        });\n        return params;\n    }\n    /**\n     * Normalizes AppSync realtime endpoint URL\n     *\n     * @param appSyncGraphqlEndpoint - AppSync endpointUri from config\n     * @param urlParams - URLSearchParams\n     * @returns fully resolved string realtime endpoint URL\n     */\n    _realtimeUrlWithQueryString(appSyncGraphqlEndpoint, urlParams) {\n        const protocol = 'wss://';\n        let realtimeEndpoint = appSyncGraphqlEndpoint ?? '';\n        if (this.isCustomDomain(realtimeEndpoint)) {\n            realtimeEndpoint = realtimeEndpoint.concat(customDomainPath);\n        }\n        else {\n            realtimeEndpoint = realtimeEndpoint\n                .replace('appsync-api', 'appsync-realtime-api')\n                .replace('gogi-beta', 'grt-beta');\n        }\n        realtimeEndpoint = realtimeEndpoint\n            .replace('https://', protocol)\n            .replace('http://', protocol);\n        const realtimeEndpointUrl = new AmplifyUrl(realtimeEndpoint);\n        // preserves any query params a customer might manually set in the configuration\n        const existingParams = new AmplifyUrlSearchParams(realtimeEndpointUrl.search);\n        for (const [k, v] of urlParams.entries()) {\n            existingParams.append(k, v);\n        }\n        realtimeEndpointUrl.search = existingParams.toString();\n        return realtimeEndpointUrl.toString();\n    }\n    _initializeWebSocketConnection({ appSyncGraphqlEndpoint, authenticationType, apiKey, region, additionalCustomHeaders, }) {\n        if (this.socketStatus === SOCKET_STATUS.READY) {\n            return;\n        }\n        // TODO(Eslint): refactor to now use async function as the promise executor\n        // eslint-disable-next-line no-async-promise-executor\n        return new Promise(async (resolve, reject) => {\n            this.promiseArray.push({ res: resolve, rej: reject });\n            if (this.socketStatus === SOCKET_STATUS.CLOSED) {\n                try {\n                    this.socketStatus = SOCKET_STATUS.CONNECTING;\n                    const payloadString = '{}';\n                    const authHeader = await this._awsRealTimeHeaderBasedAuth({\n                        authenticationType,\n                        payload: payloadString,\n                        canonicalUri: '/connect',\n                        apiKey,\n                        appSyncGraphqlEndpoint,\n                        region,\n                        additionalCustomHeaders,\n                    });\n                    const headerString = authHeader ? JSON.stringify(authHeader) : '';\n                    // base64url-encoded string\n                    const encodedHeader = base64Encoder.convert(headerString, {\n                        urlSafe: true,\n                        skipPadding: true,\n                    });\n                    const authTokenSubprotocol = `header-${encodedHeader}`;\n                    const queryParams = this._queryParamsFromCustomHeaders(additionalCustomHeaders);\n                    const awsRealTimeUrl = this._realtimeUrlWithQueryString(appSyncGraphqlEndpoint, queryParams);\n                    await this._initializeRetryableHandshake(awsRealTimeUrl, authTokenSubprotocol);\n                    this.promiseArray.forEach(({ res }) => {\n                        logger.debug('Notifying connection successful');\n                        res();\n                    });\n                    this.socketStatus = SOCKET_STATUS.READY;\n                    this.promiseArray = [];\n                }\n                catch (err) {\n                    logger.debug('Connection exited with', err);\n                    this.promiseArray.forEach(({ rej }) => {\n                        rej(err);\n                    });\n                    this.promiseArray = [];\n                    if (this.awsRealTimeSocket &&\n                        this.awsRealTimeSocket.readyState === WebSocket.OPEN) {\n                        this.awsRealTimeSocket.close(3001);\n                    }\n                    this.awsRealTimeSocket = undefined;\n                    this.socketStatus = SOCKET_STATUS.CLOSED;\n                }\n            }\n        });\n    }\n    async _initializeRetryableHandshake(awsRealTimeUrl, subprotocol) {\n        logger.debug(`Initializaling retryable Handshake`);\n        await jitteredExponentialRetry(this._initializeHandshake.bind(this), [awsRealTimeUrl, subprotocol], MAX_DELAY_MS);\n    }\n    /**\n     *\n     * @param subprotocol -\n     */\n    async _initializeHandshake(awsRealTimeUrl, subprotocol) {\n        logger.debug(`Initializing handshake ${awsRealTimeUrl}`);\n        // Because connecting the socket is async, is waiting until connection is open\n        // Step 1: connect websocket\n        try {\n            await (() => {\n                return new Promise((resolve, reject) => {\n                    const newSocket = this.getNewWebSocket(awsRealTimeUrl, [\n                        'graphql-ws',\n                        subprotocol,\n                    ]);\n                    newSocket.onerror = () => {\n                        logger.debug(`WebSocket connection error`);\n                    };\n                    newSocket.onclose = () => {\n                        reject(new Error('Connection handshake error'));\n                    };\n                    newSocket.onopen = () => {\n                        this.awsRealTimeSocket = newSocket;\n                        resolve();\n                    };\n                });\n            })();\n            // Step 2: wait for ack from AWS AppSyncReaTime after sending init\n            await (() => {\n                return new Promise((resolve, reject) => {\n                    if (this.awsRealTimeSocket) {\n                        let ackOk = false;\n                        this.awsRealTimeSocket.onerror = error => {\n                            logger.debug(`WebSocket error ${JSON.stringify(error)}`);\n                        };\n                        this.awsRealTimeSocket.onclose = event => {\n                            logger.debug(`WebSocket closed ${event.reason}`);\n                            reject(new Error(JSON.stringify(event)));\n                        };\n                        this.awsRealTimeSocket.onmessage = (message) => {\n                            if (typeof message.data !== 'string') {\n                                return;\n                            }\n                            logger.debug(`subscription message from AWS AppSyncRealTime: ${message.data} `);\n                            const data = JSON.parse(message.data);\n                            const { type, payload: { connectionTimeoutMs = DEFAULT_KEEP_ALIVE_TIMEOUT, } = {}, } = data;\n                            if (type === MESSAGE_TYPES.GQL_CONNECTION_ACK) {\n                                ackOk = true;\n                                if (this.awsRealTimeSocket) {\n                                    this.keepAliveTimeout = connectionTimeoutMs;\n                                    this.awsRealTimeSocket.onmessage =\n                                        this._handleIncomingSubscriptionMessage.bind(this);\n                                    this.awsRealTimeSocket.onerror = err => {\n                                        logger.debug(err);\n                                        this._errorDisconnect(CONTROL_MSG.CONNECTION_CLOSED);\n                                    };\n                                    this.awsRealTimeSocket.onclose = event => {\n                                        logger.debug(`WebSocket closed ${event.reason}`);\n                                        this._errorDisconnect(CONTROL_MSG.CONNECTION_CLOSED);\n                                    };\n                                }\n                                resolve('Cool, connected to AWS AppSyncRealTime');\n                                return;\n                            }\n                            if (type === MESSAGE_TYPES.GQL_CONNECTION_ERROR) {\n                                const { payload: { errors: [{ errorType = '', errorCode = 0 } = {}] = [], } = {}, } = data;\n                                // TODO(Eslint): refactor to reject an Error object instead of a plain object\n                                // eslint-disable-next-line prefer-promise-reject-errors\n                                reject({ errorType, errorCode });\n                            }\n                        };\n                        const gqlInit = {\n                            type: MESSAGE_TYPES.GQL_CONNECTION_INIT,\n                        };\n                        this.awsRealTimeSocket.send(JSON.stringify(gqlInit));\n                        const checkAckOk = (targetAckOk) => {\n                            if (!targetAckOk) {\n                                this.connectionStateMonitor.record(CONNECTION_CHANGE.CONNECTION_FAILED);\n                                reject(new Error(`Connection timeout: ack from AWSAppSyncRealTime was not received after ${CONNECTION_INIT_TIMEOUT} ms`));\n                            }\n                        };\n                        setTimeout(() => {\n                            checkAckOk(ackOk);\n                        }, CONNECTION_INIT_TIMEOUT);\n                    }\n                });\n            })();\n        }\n        catch (err) {\n            const { errorType, errorCode } = err;\n            if (NON_RETRYABLE_CODES.includes(errorCode)) {\n                throw new NonRetryableError(errorType);\n            }\n            else if (errorType) {\n                throw new Error(errorType);\n            }\n            else {\n                throw err;\n            }\n        }\n    }\n    async _awsRealTimeHeaderBasedAuth({ apiKey, authenticationType, payload, canonicalUri, appSyncGraphqlEndpoint, region, additionalCustomHeaders, }) {\n        const headerHandler = {\n            apiKey: this._awsRealTimeApiKeyHeader.bind(this),\n            iam: this._awsRealTimeIAMHeader.bind(this),\n            oidc: this._awsAuthTokenHeader.bind(this),\n            userPool: this._awsAuthTokenHeader.bind(this),\n            lambda: this._customAuthHeader,\n            none: this._customAuthHeader,\n        };\n        if (!authenticationType || !headerHandler[authenticationType]) {\n            logger.debug(`Authentication type ${authenticationType} not supported`);\n            return undefined;\n        }\n        else {\n            const handler = headerHandler[authenticationType];\n            const host = appSyncGraphqlEndpoint\n                ? new AmplifyUrl(appSyncGraphqlEndpoint).host\n                : undefined;\n            logger.debug(`Authenticating with ${JSON.stringify(authenticationType)}`);\n            let resolvedApiKey;\n            if (authenticationType === 'apiKey') {\n                resolvedApiKey = apiKey;\n            }\n            const result = await handler({\n                payload,\n                canonicalUri,\n                appSyncGraphqlEndpoint,\n                apiKey: resolvedApiKey,\n                region,\n                host,\n                additionalCustomHeaders,\n            });\n            return result;\n        }\n    }\n    async _awsAuthTokenHeader({ host }) {\n        const session = await fetchAuthSession();\n        return {\n            Authorization: session?.tokens?.accessToken?.toString(),\n            host,\n        };\n    }\n    async _awsRealTimeApiKeyHeader({ apiKey, host, }) {\n        const dt = new Date();\n        const dtStr = dt.toISOString().replace(/[:-]|\\.\\d{3}/g, '');\n        return {\n            host,\n            'x-amz-date': dtStr,\n            'x-api-key': apiKey,\n        };\n    }\n    async _awsRealTimeIAMHeader({ payload, canonicalUri, appSyncGraphqlEndpoint, region, }) {\n        const endpointInfo = {\n            region,\n            service: 'appsync',\n        };\n        const creds = (await fetchAuthSession()).credentials;\n        const request = {\n            url: `${appSyncGraphqlEndpoint}${canonicalUri}`,\n            data: payload,\n            method: 'POST',\n            headers: { ...AWS_APPSYNC_REALTIME_HEADERS },\n        };\n        const signedParams = signRequest({\n            headers: request.headers,\n            method: request.method,\n            url: new AmplifyUrl(request.url),\n            body: request.data,\n        }, {\n            // TODO: What do we need to do to remove these !'s?\n            credentials: creds,\n            signingRegion: endpointInfo.region,\n            signingService: endpointInfo.service,\n        });\n        return signedParams.headers;\n    }\n    _customAuthHeader({ host, additionalCustomHeaders, }) {\n        /**\n         * If `additionalHeaders` was provided to the subscription as a function,\n         * the headers that are returned by that function will already have been\n         * provided before this function is called.\n         */\n        if (!additionalCustomHeaders?.Authorization) {\n            throw new Error('No auth token specified');\n        }\n        return {\n            Authorization: additionalCustomHeaders.Authorization,\n            host,\n        };\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}